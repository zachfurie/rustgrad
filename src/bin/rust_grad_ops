
use rand::prelude::*;

//  ----------------------------------- Data Structures:  -----------------------------------

// struct Node<'a> {
//     left: &'a Node<'a>,
// 	right: &'a Node<'a>,
// 	op: String,
// 	tensor: &'a Tensor,
// 	grad: &'a Tensor,
// 	require_grad: bool,
// }



struct Tensor {
	data:  Vec<f64>, // Float64 all tensor data in a single slice 
	shape: Vec<usize>, // Int  [i] = length of dimension i
}

//  ----------------------------------- Auxiliary Functions:  -----------------------------------

impl Tensor {
    fn zeros(shaper: &Vec<usize>) -> Tensor {
        let mut data_len: usize = 1;
        for i in shaper {
            data_len *= i
        }
        Tensor {
            data:  vec![0.; data_len], // all tensor data in a single slice 
            shape: shaper.to_vec() // [i] = length of dimension i
        }
    }

    fn ones(shaper: &Vec<usize>) -> Tensor {
        let mut data_len: usize = 1;
        for i in shaper {
            data_len *= i
        }
        Tensor {
            data:  vec![1.; data_len], // all tensor data in a single slice 
            shape: shaper.to_vec() // [i] = length of dimension i
        }
    }

    fn xavier(shaper: &Vec<usize>) -> Tensor {
        let mut data_len: usize = 1;
        for i in shaper {
            data_len *= i
        }
        let std = (shaper[shaper.len()-1] as f64).sqrt();
        let mut rng = rand::thread_rng();
        let mut t = Tensor {
            data:  vec![1.; data_len], // all tensor data in a single slice 
            shape: shaper.to_vec() // [i] = length of dimension i
        };
        for i in 0..data_len {
            let y: f64 = rng.gen(); // generates a float between 0 and 1
            if rng.gen_bool(0.5) {
                t.data[i] = y / std; // generates a float between 0 and 1
            } else {
                t.data[i] = -1. * y / std; // generates a float between 0 and 1
            }
        };
        t
    }

    fn get(&self, ind: Vec<usize>) -> f64 {
        let mut index = 0;
        for (i,x) in ind[..ind.len()-1].iter().enumerate() {
            index += self.shape[i+1] * x
        };
        index += ind[ind.len()-1];
        self.data[index]
    }
    
    fn set(&mut self, ind: Vec<usize>, elem: f64) {
        let mut index = 0;
        for (i,x) in ind[..ind.len()-1].iter().enumerate() {
            index += self.shape[i+1] * x
        };
        index += ind[ind.len()-1];
        self.data[index] = elem;
    }

    fn l2(&self) -> usize {
        self.shape[self.shape.len()-2]
    }

    fn l(&self) -> usize {
        self.shape[self.shape.len()-1]
    }

    fn copy_tens(&self) -> Tensor {
        let new_shape = self.shape.to_vec();
        let new_data = self.data.to_vec();
        Tensor {
            data:  new_data, // all tensor data in a single slice 
            shape: new_shape, // [i] = length of dimension i
        }
    }
}

fn add_same_size(dst: &mut Tensor, t: &Tensor ) {
    for (i,_) in t.data.iter().enumerate() {
        dst.data[i] += t.data[i]
    }
}

//  ----------------------------------- BASIC OPS:  -----------------------------------


// ----------------------------------- TESTING (will be removed when done) -----------------------------------

pub(crate) fn test() {
    let s: Vec<usize> = vec![2,2];
    let mut a = Tensor::xavier(&s);
    let mut b = a.copy_tens();
    let ind = vec![0,0];
    a.set(ind, 1.);
    let ind = vec![0,1];
    a.set(ind, 2.);
    let ind = vec![1,0];
    a.set(ind, 3.);
    let ind = vec![1,1];
    a.set(ind, 4.);

    let ind1 = vec![0,0];
    let ind2 = vec![0,1];
    let ind3 = vec![1,0];
    let ind4 = vec![1,1];
    println!("{} {}", a.get(ind1), a.get(ind2));
    println!("{} {}", a.get(ind3), a.get(ind4));
    let ind1 = vec![0,0];
    let ind2 = vec![0,1];
    let ind3 = vec![1,0];
    let ind4 = vec![1,1];
    println!("{} {}", b.get(ind1), b.get(ind2));
    println!("{} {}", b.get(ind3), b.get(ind4));

    add_same_size(&mut b, &a);

    let ind1 = vec![0,0];
    let ind2 = vec![0,1];
    let ind3 = vec![1,0];
    let ind4 = vec![1,1];
    println!("{} {}", a.get(ind1), a.get(ind2));
    println!("{} {}", a.get(ind3), a.get(ind4));
    let ind1 = vec![0,0];
    let ind2 = vec![0,1];
    let ind3 = vec![1,0];
    let ind4 = vec![1,1];
    println!("{} {}", b.get(ind1), b.get(ind2));
    println!("{} {}", b.get(ind3), b.get(ind4));

    
}
